# x86-64 asm (gnu/linux)


## syscalls

* syscall number: rax
* syscall args: rdi rsi rdx r10 r8 r9
* return value: rax

[syscall table](https://github.com/torvalds/linux/blob/567cfea99af61ef19da42f8491da98cf94a4d166/arch/x86/syscalls/syscall_64.tbl#L9-L331)


### pause

    rax=34

* [syscall_64.tbl](https://github.com/torvalds/linux/blob/567cfea99af61ef19da42f8491da98cf94a4d166/arch/x86/syscalls/syscall_64.tbl#L43)
* [signal.c](https://github.com/torvalds/linux/blob/567cfea99af61ef19da42f8491da98cf94a4d166/kernel/signal.c#L3550-L3557)

    make -f asm.mk


### exit

    rax=60, rdi=0

* [syscall_64.tbl](https://github.com/torvalds/linux/blob/567cfea99af61ef19da42f8491da98cf94a4d166/arch/x86/syscalls/syscall_64.tbl#L69)
* [exit.c](https://github.com/torvalds/linux/blob/567cfea99af61ef19da42f8491da98cf94a4d166/kernel/exit.c#L843-L846)

    make -f asm.mk


## encoding

C-string are null-terminated; avoid null bytes in opcodes for injection

### encode.sh

    ./Encode.sh ObjFile

dumps objfile's instruction mnemonics as sequence of opcodes in hex


### nulls.sh

    ./Nulls.sh ObjFile

searches objfile's instruction opcodes for null bytes and shows offending mnemonic


### inject

    static const char ops[] = "\x48\x31\xc0\xb0\x22\x0f\x05";

    int main(int /*argc*/, char** /*argv*/) {
        typedef void(*fnType)();
        fnType fn = (fnType)ops;
        fn();
    }

inject opcodes generated by Encode.sh; if you have to handle C-string semantic check with Nulls.sh

why does it work?

* ops is placed into the ELF's .rodata section
* .rodata and .text [gets merged by default](https://sourceware.org/ml/binutils/2014-05/msg00111.html)
* .rodata is now executable, too

notes:

* ld.gold's --rosegment places .rodata into read-only non-executable section
* see ld's -z execstack
* try with stack-based ops, nx bit
* see mprotect


### jit

    make -s -f cc.mk; ./Jit
    -w- blob at 0x7faee5559000 size 4096
    r-x blob at 0x7faee5559000 size 4096
    

see Jit.cc and its comments; it works like this:

* mmap memory, writable
* write machine code into it
* change protection to readable, executable
* execute machine code


## utilities

### gdb

add to ~/.gdbinit:

    set disassembly-flavor intel

registers:

    info registers

disassemble:

    disassemble _start

gui with register view:

    gdb -tui
    layout split
    tui reg general


### objdump

symbol table entries:

    objdump -t

assembler mnemonics

    objdump -d


## License

Copyright Â© 2015 Daniel J. Hofmann

Distributed under the MIT License (MIT).
